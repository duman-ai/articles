---
import Footer from '../components/Footer.astro';
import Head from '../components/Head.astro';
import Author from '../components/Author.astro';
import DumanLogo from '../components/DumanLogo.astro';
---

<Head />

<header>
  <DumanLogo />
  <h1>پرامپت و تکنیک‌های آن</h1>
  <div class="post-meta">
    <span>🗓️ تاریخ انتشار: ۱۱ می ۲۰۲۵</span>
    <Author />
  </div>
</header>

<main>
  <div class="post">
    <p>
      پرامپت (Prompt) ورودی مدل‌ زبانی است که برای رسیدن به پاسخ مورد نظر نوشته می‌شود. یک پرامپت از
      اجزای مختلفی ساخته شده که مشخص کردن آن‌ها کاربر را برای رسیدن به پاسخ بهتر در زمان کم کمک ‌می‌کند.
      الزاماً تمامی این اجزا در یک پرامپت وجود ندارد. در ادامه هر کدام از این اجزا با مثالی که در تصویر زیر
      نمایش داده شده معرفی می‌شود. برای استفاده صحیح از مدل‌های زبانی صرفاً نوشتن پرامپت کافی نیست. بلکه باید
      پارامترهای مهم در پیکربندی مدل را نیز بشناسید. برای آشنایی بیشتر با این پارامترها <a href="llm-inference-configuration.html">اینجا</a> را
      بخوانید.
    </p>

    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <img
        src="https://i.postimg.cc/XYkw4rwF/prompt-example.jpg"
        alt="مثال بررسی پرامپت و اجزای آن"
        style="max-width: 50%; height: auto;"
      />
      <p style="font-size: 14px; color: #555; margin-top: 8px;">مثال بررسی پرامپت و اجزای آن</p>
    </div>

    <h4 dir="ltr" style="font-weight: bold;">Instruction:</h4>
    <p>دستوراتی که می‌خواهیم اجرا شود. در اینجا سورت کردن از بیشترین به کمترین و محاسبه بازدهی به درصد دستورات پرامپت هستند.</p>

    <h4 dir="ltr" style="font-weight: bold;">Context:</h4>
    <p>اطلاعاتی که به مشخص شدن حوزه مورد درخواست کمک کرده و یا آن را محدودتر می‌کند. در اینجا عبارت "در این جدل قیمت خرید و فروش سهام مشخص شده است." موضوع را مشخص می‌کند.</p>

    <h4 dir="ltr" style="font-weight: bold;">Input Data:</h4>
    <p>اطلاعاتی که به عنوان ورودی نیاز است. در اینجا محتوای فایل CSV دیتای ورودی مورد نیاز مدل است.</p>

    <h4 dir="ltr" style="font-weight: bold;">Output Indicator:</h4>
    <p>شکل یا فرمت پاسخی که انتظار داریم را مشخص کنیم. در اینجا عبارات به صورت جدول و بدون توضیحات و کد شکل خروجی مورد انتظار را مشخص می‌کند.</p>

    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <img
        src="https://i.postimg.cc/X7w5kr1h/prompt-structure.webp"
        alt="اجزای پرامپت"
        style="max-width: 75%; height: auto;"
      />
      <p style="font-size: 14px; color: #555; margin-top: 8px;">اجزای پرامپت</p>
    </div>

    <p>در ادامه رایج‌ترین تکنیک‌های پرامپت‌نویسی معرفی می‌شود.</p>

    <h3 dir="ltr">1. ZeroShot Prompting (General Prompting):</h3>
    <p>این تکنیک ساده‌ترین روش پرامپت نویسی است. در این روش کاربر سوال خود را در یک پیام از مدل زبانی می‌پرسد. با توسعه مدل‌های زبانی توانایی آن برای پاسخ دادن به گستره‌ای بزرگ و متنوع از حوزه‌ها افزایش پیدا کرده و این روش ساده به راحتی قابل استفاده خواهد بود. اگر روش  ZeroShot کاربر را به پاسخ نرساند تکنیک‌های پیشرفته‌تر مورد استفاده قرار می‌گیرد.</p>

    <h3 dir="ltr">2. FewShot Prompting:</h3>
    <p>در این تکنیک کاربر چند مثال برای مدل فراهم می‌کند تا آن را برای رسیدن به الگو و پاسخ مورد نظر خود هدایت کند. تفاوت روش FewShot و ZeroShot در تعداد مثال‌هاست. روش FewShot برای سوالات پیچیده‌تر به کار می‌رود. فراهم کردن مثال‌های متعدد مدل را برای یادگیری روش پاسخگویی به یک تسک/سوال هدایت می‌کند که به آن In-context learning (ICL) گفته می‌شود. </p>

    <h3 dir="ltr">3. Chain of Thoughts (CoT):</h3>
    <p>در این روش مدل زبانی برای تولید قدم‌های میانی در استنتاج و محاسبات هدایت می‌شود. به عبارت دیگر مدل قدم به قدم روش محاسبه خود را شرح داده و طبق آن پیش می‌رود. این تکنیک به تولید پاسخ دقیق در تسک‌های ریاضیاتی و استنتاجی کمک می‌کند. معمولاً تکنیک Chain of Thoughts به همراه FewShot Prompting  به‌کار می‌رود. در تصویر زیر نتیجه روش Chain of Thoughts در مقایسه با ZeroShot Prompting مقایسه شده است. معمولاً برای هدایت مدل با تکنیک Chain of Thoughts باید حداقل یک مثال به آن ارائه شده و از آن درخواست شود مشابه مثال قدم به قدم (Step by Step) پاسخ دهد. </p>

    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <img
        src="https://i.postimg.cc/NjBHJQW0/cot-example.png"
        alt="مقایسه Chain of Thoughts و ZeroShot"
        style="max-width: 75%; height: auto;"
      />
      <p style="font-size: 14px; color: #555; margin-top: 8px;">مقایسه Chain of Thoughts و ZeroShot</p>
    </div>

    <p>نسخه جامع‌تر Chain of Thoughts (CoT) روش Tree of Thoughts (ToT) نام دارد. در ToT به جای یک مسیر مستقیم از استنتاج مسیرهای پیچیده‌تری از استنتاج طی می‌شود. برای مقایسه CoT و ToT تصویر زیر را مشاهده کنید. </p>

    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <img
        src="https://i.postimg.cc/s20Gg71B/tot-cot.png"
        alt="مقایسه ToTو CoT"
        style="max-width: 75%; height: auto;"
      />
      <p style="font-size: 14px; color: #555; margin-top: 8px;">مقایسه ToTو CoT</p>
    </div>

    <h3 dir="ltr">4. ReAct (Reasoning and Action):</h3>
    <p>این روش از سرویس‌ها و ابزارهای خارجی در تسک‌های پیچیده نظیر برنامه‌نویسی فیدبک می‌گیرد. روش ReAct از رفتار انسان تقلید کرده و در ایجنت‌های مبتنی بر LLM بسیار مورد استفاده قرار می‌گیرد. به عنوان مثال در نظر بگیرید می‌خواهید با LLM برای یک مساله برنامه بنویسید. بعد از تولید کد آن را اجرا کرده و خطای آن را دوباره به مدل می‌دهید و از آن می‌خواهید که این خطا را تصحیح کند. این چرخه تا رسیدن به پاسخ صحیح ادامه پیدا می‌کند. این چرخه شامل قدم‌های متوالی Reasoning و Action است. در Reasoning مدل پاسخ پیشنهادی را تولید کرده و در Action نتیجه پاسخ قبلی در ابزارها (محیط برنامه‌نویسی، موتور جستجو و یا APIهای سرویس خارجی) اجرا می‌شود. اگر کاربر به پاسخ خود رسیده باشد چرخه قطع شده و در غیر این صورت از نتایج Action برای Reasoning جدید استفاده می‌شود. این چرخه در تصویر زیر نمایش داده شده است. </p>

    <div style="display: flex; flex-direction: column; align-items: center; margin-bottom: 20px;">
      <img
        src="https://i.postimg.cc/h4mQKJnj/react.png"
        alt="فلوی ReAct"
        style="max-width: 75%; height: auto;"
      />
      <p style="font-size: 14px; color: #555; margin-top: 8px;">فلوی ReAct</p>
    </div>

    <h3 dir="ltr">5. Self-Consistency:</h3>
    <p>در این روش با استفاده از CoT مسیرهای مختلف استنتاج توسط مدل پیشنهاد شده و در نهایت کاربر مناسب‌ترین مسیر را انتخاب می‌کند. در واقع روش Self-Consistency عملکرد تکنیک CoT را تقویت می‌کند، در عین حال هزینه استفاده از مدل نیز بالاتر می‌رود زیرا به جای یک پاسخ چند پاسخ تولید شده است. </p>

    <h3 dir="ltr">6. Meta Prompting:</h3>
    <p>در این روش از مدل زبانی (ترجیحاً مدل‌های قدرتمندتر) برای ساختن پرامپت یا بهینه کردن یک پرامپت استفاده می‌شود. شما می‌توانید از یک مدل زبانی بخواهید پرامپت شما را ویرایش کند یا آن را برای کاهش هزینه (براساس سایز توکن ورودی و خروجی) بهینه کند. حتی می‌توانید با فراهم جزئیات از یک مدل بخواهید که برای شما پرامپت مناسب را تولید کند. </p>

    <h3 dir="ltr">7. System/ Role prompting:</h3>
    <p>معمولاً در مدل‌هایی زبانی تصویر کلی آن چیزی که از مدل انتظار در قالب System Prompt یا Instructions مشخص می‌شود.</p>
    <p>مثال از فرمت خروجی: همیشه در این ساختار Json Schema پاسخ بده …</p>
    <p>مثال از آموزش زبان انگلیسی: فرض کن معلم زبان انگلیسی هستی و در حال یاد دادن زبان به کاربر فارسی زبان هستی.</p>
    <p>همان‌طور که در مثال قبلی مشاهده کردید، یکی از راه‌های هدایت مدل به سمت نیاز کاربر مشخص کردن نقش (Role) آن است. به همین جهت زمانی که در پرامپت از مدل می‌خواهیم در نقش مورد نظر ما ظاهر شود به آن <strong>Role Prompting</strong> گفته می‌شود.</p>

    <h3>مطالعه بیشتر در:</h3>
    <ul dir="ltr">
      <li><a href="https://tonylixu.medium.com/langchain-prompt-template-0359d96090c5" target="_blank">LangChain — Prompt Template. What is a Prompt</a></li>
      <li><a href="https://www.kaggle.com/whitepaper-prompt-engineering" target="_blank">Prompt Engineering by Google</a></li>
      <li><a href="https://www.promptingguide.ai/" target="_blank">Prompt Engineering Guide</a></li>
      <li><a href="https://cobusgreyling.medium.com/react-synergy-between-reasoning-acting-in-llms-36fc050ae8c7" target="_blank">ReAct: Synergy Between Reasoning & Acting In LLMs | by Cobus Greyling</a></li>
    </ul>

  </div>
</main>

<Footer />
